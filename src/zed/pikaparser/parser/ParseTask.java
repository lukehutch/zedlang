package zed.pikaparser.parser;

import java.util.TreeMap;

import zed.pikaparser.grammar.Grammar;
import zed.pikaparser.grammar.expr.Expr;
import zed.pikaparser.parser.memo.Memo;
import zed.pikaparser.parser.memo.MemoTable;

// FIXME: get rid of this class
public class ParseTask {

    final String input;

    final Expr topRule;

    final Expr recoveryLevelExpr;

    final MemoTable memoTable;

    public ParseTask(Grammar grammar, String input) {
        this.input = input;
        this.topRule = grammar.getTopExpr();
        this.recoveryLevelExpr = grammar.getRecoveryLevelExpr();
        this.memoTable = new MemoTable(grammar, input);
    }

    public Memo parse() {
        // BOTTOM-UP PARSE
        BottomUpParser bottomUpParser = new BottomUpParser(memoTable);
        bottomUpParser.parse(); // (Updates exprIdxToMemos)

        // TOP-DOWN PARSE
        // TODO: Use the memo table generated by bottom-up parsing for the purpose of recovery after syntax errors:
        // decide what level of granularity you want to use to recover from syntax errors, then after the input
        // stops matching, scan ahead in the memo table to find the next match for that rule type, and you get the
        // next valid parse sequence at that level of granularity. Then scan the final-sibling path down the parse
        // tree to find the sequence rule immediately before that one at the same level of granularity, skip the
        // non-parseable gap, and resume the top-down parse from that point.
        TopDownParser topDownParser = new TopDownParser(memoTable);
        topDownParser.parse(); // (Updates exprIdxToMemos)
        Memo topMatch = topDownParser.getTopMatch();

        // ERROR RECOVERY (if needed)
        TreeMap<Integer, Integer> syntaxErrors = null;
        if (!topMatch.matches()) {
            // Nothing matched top-down (i.e. no expr trees were parseable as high as the top rule)
            // TODO can still return a list of matching input spans at some level of granulatity
            System.out.println("Matched no input"); // TODO: figure out how to do error reporting
            syntaxErrors = new TreeMap<>();
            syntaxErrors.put(0, input.length());

        } else if (topMatch.endPos < input.length()) {
            // Didn't match all the input
            if (recoveryLevelExpr == null) {
                // No recovery level specified, so everything from the last match to the end of input is a syntax error
                syntaxErrors = new TreeMap<>();
                syntaxErrors.put(topMatch.endPos, input.length());
            } else {
                // Try skipping syntax errors using a recovery parser
                ErrorRecoveryParser recoveryParser = new ErrorRecoveryParser(memoTable);
                recoveryParser.parse();
                topMatch = recoveryParser.getTopMatch();
                syntaxErrors = recoveryParser.getSyntaxErrors();
            }
        }

        // Print memos
        System.out.println();
        memoTable.printTable(syntaxErrors);

        // TODO: get rid of requirement to have TOP rule, and simply see if any rule matched the entire sequence. If more than one,
        // return the first rule in the order listed by the user.

        // See if TOP matched the whole input
        if (!topMatch.matches()) {
            // TODO: Figure out how to give meaningful errors
            // TODO: and keep track of max successful matched endIdx so far, so syntax err position can be reported
            System.err.println("\nDid not match input");
        } else if (topMatch.endPos < input.length()) {
            System.err.println("\nThere were " + (input.length() - topMatch.endPos)
                    + " unmatched characters at the end of the input: " + input.substring(topMatch.endPos));
        }

        return topMatch;
    }
}
