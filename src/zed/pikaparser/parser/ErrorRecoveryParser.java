package zed.pikaparser.parser;

import java.util.HashSet;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentSkipListMap;

import zed.pikaparser.grammar.expr.Expr;
import zed.pikaparser.parser.memo.Memo;
import zed.pikaparser.parser.memo.MemoTable;
import zed.pikaparser.parser.memo.MemoTable.MemoRef;

public class ErrorRecoveryParser extends DirectionalParser {

    /** The MemoRef nodes in the recursion stack (used to detect cycles) */
    private HashSet<MemoRef> topDownPathNodes = new HashSet<>();

    /** Max number of syntax errors to try to recover from. */
    private static final int MAX_ERRORS = 10;

    /** The level of expression at which to try to recover after errors. */
    private Expr recoveryLevelExpr;

    private Memo syntaxErrorStartMatch;

    private Memo syntaxErrorEndMatch;

    /** Map from start index to end index for syntax errors */
    private TreeMap<Integer, Integer> syntaxErrors = new TreeMap<>();

    private Memo topMatch;
    
    private Expr topRule;
    
    private MemoRef topMemoRef;
    
    /** Get the top match of this parse. Check .matches() on the result to see if anything matched. */
    public Memo getTopMatch() {
        return topMatch;
    }

    /** Syntax errors, as a sorted map from start index to end index of the unparseable input. */
    public TreeMap<Integer, Integer> getSyntaxErrors() {
        return syntaxErrors;
    }

    public ErrorRecoveryParser(MemoTable memoTable) {
        super(memoTable);
        this.recoveryLevelExpr = memoTable.grammar.recoveryLevelExpr;

        this.topRule = memoTable.grammar.getTopExpr();
        this.topMemoRef = new MemoRef(topRule, 0);

        // TODO: is this right?
        this.topMatch = memoTable.getEntry(this.topMemoRef);

    }

    @Override
    public void parse() {
        for (int i = 0; i < MAX_ERRORS; i++) {
            // First pass: look for last mismatching expr at recovery level (the last child memo of a
            // OneOrMore expr will always be a mismatching memo entry)
            syntaxErrorStartMatch = syntaxErrorEndMatch = null;
            this.topMatch = topRule.match(this, topMemoRef);
            if (syntaxErrorStartMatch == null) {
                // Couldn't find an expr at the recovery level
                break;
            }

            // Try skipping one or more characters of input to extend the OneOrMore expr that wraps the
            // recovery level expr
            ConcurrentSkipListMap<Integer, Memo> startIdxToMemo = memoTable
                    .getAllMemosForExpr(syntaxErrorStartMatch.ref.expr);
            Entry<Integer, Memo> nextMatch = startIdxToMemo.ceilingEntry(syntaxErrorStartMatch.endPos + 1);
            if (nextMatch != null) {
                syntaxErrorEndMatch = nextMatch.getValue();
                syntaxErrors.put(syntaxErrorStartMatch.endPos, syntaxErrorEndMatch.ref.pos);
            } else {
                // Couldn't find an additional expr at the recovery level after skipping some invalid input
                break;
            }

            // Second pass: extend the enclosing OneOrMore with the match after the skipped input
            this.topMatch = topRule.match(this, topMemoRef);
        }

        // Add last syntax error, if not all all the input could be matched even after attempted recovery
        if (topMatch.endPos < memoTable.input.length()) {
            syntaxErrors.put(topMatch.endPos, memoTable.input.length());
        }
    }

    /**
     */
    @Override
    public Memo matchMemoized(MemoRef superExprRef /* not used */, MemoRef subExprRef) {

        // See if a memo with this MemoRef exits in the memo table 
        Memo subExprMemo = memoTable.getEntry(subExprRef);
        if (subExprMemo == null) {
            // If traversing top-down, and this memo doesn't exist, then we reached a node that wasn't
            // the root of one of the parse trees in the forest generated by bottom-up parsing.

            // Only recurse to child nodes if we haven't reached a left-recursive cycle.
            if (!topDownPathNodes.add(subExprRef)) {
                // Reached a nullable left-recursive loop (this expr at this position is already reached
                // in a higher frame of recursion)
                subExprMemo = Memo.DID_NOT_MATCH(subExprRef);

            } else {
                // No info about whether this expr matches at this position, need to recursively match
                subExprMemo = subExprRef.expr.match(this, subExprRef);

                // Remove the node from the set of nodes in the recursive path once this frame exits 
                topDownPathNodes.remove(subExprRef);
            }
            // Update the memo table
            memoTable.updateEntry(subExprMemo);

        }

        if (subExprMemo.ref.expr.idx == 17) {
            System.out.println("here");
        }

        if (!subExprMemo.matches()) {

            if (subExprMemo.ref.expr == recoveryLevelExpr) {
                // If this subexpr doesn't match and the subexpr is at the recovery level

                // On the second pass, extend the match
                if (syntaxErrorEndMatch != null && subExprMemo == syntaxErrorStartMatch) {
                    // Skip over the invalid input
                    return syntaxErrorEndMatch;

                } else if (syntaxErrorStartMatch == null
                        || subExprMemo.ref.pos > syntaxErrorStartMatch.ref.pos) {
                    // On the first pass, find the highest start index for a mismatching memo at the recovery level
                    syntaxErrorStartMatch = subExprMemo;
                }
            }

        } else {
            // Found a matching memo

            if (syntaxErrorEndMatch == null) {
                // Recurse to child nodes (we have to do a complete top-down parse for each syntax error that needs
                // recovering from -- i.e. error recovery is not efficient in that it is not parallelizable, but
                // it is robust because the recovered parse tree is made up of parse fragments obtained from
                // bottom-up parsing)
                subExprMemo = subExprRef.expr.match(this, subExprRef);

            } else if (subExprMemo.endPos < syntaxErrorEndMatch.ref.pos) {
                // Optimization: on the second pass, no need to recurse to child memos that fall before the syntax error
                return subExprMemo;
            }
        }
        return subExprMemo;
    }

}