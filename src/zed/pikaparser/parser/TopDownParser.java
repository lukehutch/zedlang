package zed.pikaparser.parser;

import java.util.HashSet;

import zed.pikaparser.grammar.expr.Expr;
import zed.pikaparser.parser.memo.Memo;
import zed.pikaparser.parser.memo.MemoTable;
import zed.pikaparser.parser.memo.MemoTable.MemoRef;

public class TopDownParser extends DirectionalParser {
    protected Memo topMatch;

    /** The memo table entries in the recursion stack (used to detect cycles, in order to avoid infinite recursion) */
    private HashSet<MemoRef> topDownPathNodes = new HashSet<>();

    public TopDownParser(MemoTable memoTable) {
        super(memoTable);
    }

    @Override
    public void parse() {
        Expr topRule = memoTable.grammar.getTopExpr();
        this.topMatch = topRule.match(this, new MemoRef(topRule, 0));
    }

    /** Get the top match of this parse. Check .matches() on the result to see if anything matched. */
    public Memo getTopMatch() {
        return topMatch;
    }

    /**
     * Look up a Memo in the memo table during top-down traversal. If memo doesn't exist, create a non-matching
     * placeholder and store it in the memo table.
     */
    @Override
    public Memo matchMemoized(MemoRef superExprRef /* not used */, MemoRef subExprRef) {
        // See if a memo with this MemoRef exits in the memo table 
        Memo subExprMemo = memoTable.getEntry(subExprRef);
        if (subExprMemo == null) {
            // If traversing top-down, and this memo doesn't exist, then we reached a node that wasn't
            // the root of one of the parse trees in the forest generated by bottom-up parsing.

            // Only recurse to child nodes if we haven't reached a left-recursive cycle.
            if (!topDownPathNodes.add(subExprRef)) {
                // Reached a nullable left-recursive loop (this expr at this position is already reached
                // in a higher frame of recursion). Add a DID_NOT_MATCH node as a placeholder, so that we
                // don't try recursing infinitely to the same expression at the same position again.
                subExprMemo = Memo.DID_NOT_MATCH(subExprRef);

            } else {
                // No info about whether this expr matches at this position; recursively match
                subExprMemo = subExprRef.expr.match(this, subExprRef);

                // Remove the node from the set of nodes in the recursive path once this frame exits 
                topDownPathNodes.remove(subExprRef);
            }
            // Update the memo table
            memoTable.updateEntry(subExprMemo);
        }
        return subExprMemo;
    }
}